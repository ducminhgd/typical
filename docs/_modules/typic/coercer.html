
<!DOCTYPE html>

<html xmlns="http://www.w3.org/1999/xhtml">
  <head>
    <meta charset="utf-8" />
    <title>typic.coercer &#8212; typical 2.0.0b4 documentation</title>
    <link rel="stylesheet" href="../../_static/alabaster.css" type="text/css" />
    <link rel="stylesheet" href="../../_static/pygments.css" type="text/css" />
    <script type="text/javascript" id="documentation_options" data-url_root="../../" src="../../_static/documentation_options.js"></script>
    <script type="text/javascript" src="../../_static/jquery.js"></script>
    <script type="text/javascript" src="../../_static/underscore.js"></script>
    <script type="text/javascript" src="../../_static/doctools.js"></script>
    <script type="text/javascript" src="../../_static/language_data.js"></script>
    <link rel="canonical" href="https://seandstewart.github.io/typical/_modules/typic/coercer.html" />
    <link rel="shortcut icon" href="../../_static/favicon.ico"/>
    <link rel="index" title="Index" href="../../genindex.html" />
    <link rel="search" title="Search" href="../../search.html" />
   
  <link rel="stylesheet" href="../../_static/custom.css" type="text/css" />
  
    <link rel="apple-touch-icon" href="../../_static/favicon/apple-touch-icon.png" />
  
  
  <meta name="viewport" content="width=device-width, initial-scale=0.9, maximum-scale=0.9" />

  </head><body>
  <div class="document">
    
      <div class="sphinxsidebar" role="navigation" aria-label="main navigation">
        <div class="sphinxsidebarwrapper">
<p class="logo">
  <a href="../../index.html">
    <img class="logo" src="../../_static/logo.png" alt="Logo"/>
    
  </a>
</p>



<p class="blurb">A simple, fast, & correct data-validation library.</p>




<p>
<iframe src="https://ghbtns.com/github-btn.html?user=seandstewart&repo=typical&type=star&count=true&size=large&v=2"
  allowtransparency="true" frameborder="0" scrolling="0" width="200px" height="35px"></iframe>
</p>





    

<p>
<a class="badge" href="https://travis-ci.org/seandstewart/typical">
    <img
        alt="https://secure.travis-ci.org/seandstewart/typical.svg?branch=master"
        src="https://secure.travis-ci.org/seandstewart/typical.svg?branch=master"
    />
</a>
</p>




    

<p>
<a class="badge" href="https://codecov.io/github/seandstewart/typical">
    <img
    alt="https://codecov.io/github/seandstewart/typical/coverage.svg?branch=master"
    src="https://codecov.io/github/seandstewart/typical/coverage.svg?branch=master"
    />
</a>
</p>
<h3>Navigation</h3>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../why.html">Why <code class="docutils literal notranslate"><span class="pre">typical</span></code>?</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../overview.html"><code class="docutils literal notranslate"><span class="pre">typical</span></code> Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../usage/index.html"><code class="docutils literal notranslate"><span class="pre">typical</span></code> Usage</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../extras/index.html"><code class="docutils literal notranslate"><span class="pre">typical</span></code> Extras</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../api/index.html">Low-Level API</a></li>
</ul>

<div class="relations">
<h3>Related Topics</h3>
<ul>
  <li><a href="../../index.html">Documentation overview</a><ul>
  <li><a href="../index.html">Module code</a><ul>
  </ul></li>
  </ul></li>
</ul>
</div>
<div id="searchbox" style="display: none" role="search">
  <h3 id="searchlabel">Quick search</h3>
    <div class="searchformwrapper">
    <form class="search" action="../../search.html" method="get">
      <input type="text" name="q" aria-labelledby="searchlabel" />
      <input type="submit" value="Go" />
    </form>
    </div>
</div>
<script type="text/javascript">$('#searchbox').show(0);</script>








        </div>
      </div>
      <div class="documentwrapper">
        <div class="bodywrapper">
              <div class="related top">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          

          <div class="body" role="main">
            
  <h1>Source code for typic.coercer</h1><div class="highlight"><pre>
<span></span><span class="ch">#!/usr/bin/env python</span>
<span class="c1"># -*- coding: UTF-8 -*-</span>
<span class="kn">import</span> <span class="nn">dataclasses</span>
<span class="kn">import</span> <span class="nn">datetime</span>
<span class="kn">import</span> <span class="nn">inspect</span>
<span class="kn">import</span> <span class="nn">re</span>
<span class="kn">from</span> <span class="nn">collections</span> <span class="k">import</span> <span class="n">deque</span>
<span class="kn">from</span> <span class="nn">operator</span> <span class="k">import</span> <span class="n">attrgetter</span>
<span class="kn">from</span> <span class="nn">types</span> <span class="k">import</span> <span class="n">FunctionType</span><span class="p">,</span> <span class="n">MethodType</span>
<span class="kn">from</span> <span class="nn">typing</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">Mapping</span><span class="p">,</span>
    <span class="n">Any</span><span class="p">,</span>
    <span class="n">Union</span><span class="p">,</span>
    <span class="n">Callable</span><span class="p">,</span>
    <span class="n">Type</span><span class="p">,</span>
    <span class="n">Dict</span><span class="p">,</span>
    <span class="n">Collection</span><span class="p">,</span>
    <span class="n">Deque</span><span class="p">,</span>
    <span class="n">Optional</span><span class="p">,</span>
    <span class="n">Tuple</span><span class="p">,</span>
    <span class="n">Iterable</span><span class="p">,</span>
    <span class="n">List</span><span class="p">,</span>
    <span class="n">Pattern</span><span class="p">,</span>
    <span class="n">Match</span><span class="p">,</span>
    <span class="n">ClassVar</span><span class="p">,</span>
    <span class="n">cast</span><span class="p">,</span>
    <span class="n">TypeVar</span><span class="p">,</span>
<span class="p">)</span>

<span class="kn">from</span> <span class="nn">pendulum</span> <span class="k">import</span> <span class="n">parse</span> <span class="k">as</span> <span class="n">dateparse</span>

<span class="kn">import</span> <span class="nn">typic.schema</span> <span class="k">as</span> <span class="nn">s</span>
<span class="kn">from</span> <span class="nn">typic</span> <span class="k">import</span> <span class="n">checks</span><span class="p">,</span> <span class="n">constraints</span> <span class="k">as</span> <span class="n">const</span><span class="p">,</span> <span class="n">gen</span>
<span class="kn">from</span> <span class="nn">typic.util</span> <span class="k">import</span> <span class="p">(</span>
    <span class="n">safe_eval</span><span class="p">,</span>
    <span class="n">resolve_supertype</span><span class="p">,</span>
    <span class="n">get_args</span><span class="p">,</span>
    <span class="n">origin</span> <span class="k">as</span> <span class="n">get_origin</span><span class="p">,</span>
    <span class="n">cached_signature</span><span class="p">,</span>
    <span class="n">cached_type_hints</span><span class="p">,</span>
    <span class="n">cached_property</span><span class="p">,</span>
    <span class="n">cachedmethod</span><span class="p">,</span>
    <span class="n">fastcachedmethod</span><span class="p">,</span>
<span class="p">)</span>

<span class="n">_ORIG_SETTER_NAME</span> <span class="o">=</span> <span class="s2">&quot;__setattr_original__&quot;</span>
<span class="n">_origsettergetter</span> <span class="o">=</span> <span class="n">attrgetter</span><span class="p">(</span><span class="n">_ORIG_SETTER_NAME</span><span class="p">)</span>
<span class="n">_TYPIC_ANNOS_NAME</span> <span class="o">=</span> <span class="s2">&quot;__typic_annotations__&quot;</span>
<span class="n">_annosgetter</span> <span class="o">=</span> <span class="n">attrgetter</span><span class="p">(</span><span class="n">_TYPIC_ANNOS_NAME</span><span class="p">)</span>
<span class="n">_TOO_MANY_POS</span> <span class="o">=</span> <span class="s2">&quot;too many positional arguments&quot;</span>
<span class="n">_VAR_POSITIONAL</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span>
<span class="n">_VAR_KEYWORD</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span>
<span class="n">_KEYWORD_ONLY</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">KEYWORD_ONLY</span>
<span class="n">_POSITIONAL_ONLY</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_ONLY</span>
<span class="n">_POSITIONAL_OR_KEYWORD</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span>
<span class="n">_KWD_KINDS</span> <span class="o">=</span> <span class="p">{</span><span class="n">_VAR_KEYWORD</span><span class="p">,</span> <span class="n">_KEYWORD_ONLY</span><span class="p">}</span>
<span class="n">_POS_KINDS</span> <span class="o">=</span> <span class="p">{</span><span class="n">_VAR_POSITIONAL</span><span class="p">,</span> <span class="n">_POSITIONAL_ONLY</span><span class="p">}</span>
<span class="n">_empty</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Signature</span><span class="o">.</span><span class="n">empty</span>
<span class="n">_RETURN_KEY</span> <span class="o">=</span> <span class="s2">&quot;return&quot;</span>
<span class="n">_SELF_NAME</span> <span class="o">=</span> <span class="s2">&quot;self&quot;</span>
<span class="n">_TO_RESOLVE</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]]</span> <span class="o">=</span> <span class="p">[]</span>
<span class="n">_SCHEMA_NAME</span> <span class="o">=</span> <span class="s2">&quot;__json_schema__&quot;</span>

<span class="n">Object</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Object&quot;</span><span class="p">)</span>


<span class="n">Origin</span> <span class="o">=</span> <span class="n">TypeVar</span><span class="p">(</span><span class="s2">&quot;Origin&quot;</span><span class="p">)</span>
<span class="sd">&quot;&quot;&quot;A type alias for an instance of the type associated to a Coercer.&quot;&quot;&quot;</span>

<span class="n">Coercer</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Any</span><span class="p">],</span> <span class="n">Origin</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;A type alias for the expected signature of a type coercer.</span>

<span class="sd">Type coercers should take a value of any type and return a value of the target type.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">CoercerTypeCheck</span> <span class="o">=</span> <span class="n">Callable</span><span class="p">[[</span><span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">]],</span> <span class="nb">bool</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;A type alias for the expected signature of a type-check for a coercer.</span>

<span class="sd">Type-checkers should return a boolean indicating whether the provided type is valid for</span>
<span class="sd">a given coercer.</span>
<span class="sd">&quot;&quot;&quot;</span>
<span class="n">CoercerRegistry</span> <span class="o">=</span> <span class="n">Deque</span><span class="p">[</span><span class="n">Tuple</span><span class="p">[</span><span class="n">CoercerTypeCheck</span><span class="p">,</span> <span class="n">Coercer</span><span class="p">]]</span>


<div class="viewcode-block" id="ResolvedAnnotation"><a class="viewcode-back" href="../../usage/advanced.html#typic.api.ResolvedAnnotation">[docs]</a><span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">ResolvedAnnotation</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;An actionable run-time annotation.</span>

<span class="sd">    For the case of ``typical``, a &quot;resolved annotation&quot; is one in which we have located:</span>
<span class="sd">        - Whether there is a coercer function</span>
<span class="sd">        - Whether there is a default value</span>
<span class="sd">        - The kind of parameter (if this annotation refers to a parameter)</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">EMPTY</span> <span class="o">=</span> <span class="n">_empty</span>

    <span class="n">annotation</span><span class="p">:</span> <span class="n">Any</span>
    <span class="sd">&quot;&quot;&quot;The type annotation used to build the coercer.&quot;&quot;&quot;</span>
    <span class="n">origin</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Origin</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
    <span class="sd">&quot;&quot;&quot;The &quot;origin&quot;-type of the annotation.&quot;&quot;&quot;</span>
    <span class="n">un_resolved</span><span class="p">:</span> <span class="n">Any</span>
    <span class="sd">&quot;&quot;&quot;The type annotation before resolving super-types.&quot;&quot;&quot;</span>
    <span class="n">coercer</span><span class="p">:</span> <span class="n">Coercer</span>
    <span class="sd">&quot;&quot;&quot;The actual coercer for the annotation.&quot;&quot;&quot;</span>
    <span class="n">parameter</span><span class="p">:</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span>
    <span class="sd">&quot;&quot;&quot;The parameter this annotation refers to.&quot;&quot;&quot;</span>
    <span class="n">constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">Constraints</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="sd">&quot;&quot;&quot;Type restrictions, if any.&quot;&quot;&quot;</span>

<div class="viewcode-block" id="ResolvedAnnotation.validate"><a class="viewcode-back" href="../../usage/advanced.html#typic.api.ResolvedAnnotation.validate">[docs]</a>    <span class="k">def</span> <span class="nf">validate</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;If this annotation has any defined constraints, we can a value against them.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">constraints</span><span class="o">.</span><span class="n">validate</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">value</span></div>

<div class="viewcode-block" id="ResolvedAnnotation.coerce"><a class="viewcode-back" href="../../usage/advanced.html#typic.api.ResolvedAnnotation.coerce">[docs]</a>    <span class="k">def</span> <span class="nf">coerce</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Origin</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Coercer an in-coming ``value`` to the appropriate type defined by the anno.&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">coercer</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></div>

    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">coerce</span></div>


<span class="n">Annotations</span> <span class="o">=</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ResolvedAnnotation</span><span class="p">]</span>
<span class="sd">&quot;&quot;&quot;A mapping of attr/param name to :py:class:`ResolvedAnnotation`.&quot;&quot;&quot;</span>


<div class="viewcode-block" id="BoundArguments"><a class="viewcode-back" href="../../usage/advanced.html#typic.api.BoundArguments">[docs]</a><span class="nd">@dataclasses</span><span class="o">.</span><span class="n">dataclass</span><span class="p">(</span><span class="n">frozen</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
<span class="k">class</span> <span class="nc">BoundArguments</span><span class="p">:</span>
    <span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The object we &quot;bound&quot; the input to.&quot;&quot;&quot;</span>
    <span class="n">annotations</span><span class="p">:</span> <span class="n">Annotations</span>
    <span class="sd">&quot;&quot;&quot;A mapping of the resolved annotations.&quot;&quot;&quot;</span>
    <span class="n">parameters</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;A mapping of the parameters.&quot;&quot;&quot;</span>
    <span class="n">arguments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;A mapping of the input to parameter name.&quot;&quot;&quot;</span>
    <span class="n">returns</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ResolvedAnnotation</span><span class="p">]</span>
    <span class="sd">&quot;&quot;&quot;The resolved return type, if any.&quot;&quot;&quot;</span>
    <span class="n">_argnames</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>
    <span class="n">_kwdargnames</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">args</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Any</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;A tuple of the args passed to the callable.&quot;&quot;&quot;</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">List</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">argsappend</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">append</span>
        <span class="n">argsextend</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">extend</span>
        <span class="n">paramsget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="fm">__getitem__</span>
        <span class="n">argumentsget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="fm">__getitem__</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_argnames</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">paramsget</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">kind</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">argumentsget</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                <span class="n">argsextend</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">argsappend</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>

    <span class="nd">@cached_property</span>
    <span class="k">def</span> <span class="nf">kwargs</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;A mapping of the key-word arguments passed to the callable.&quot;&quot;&quot;</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="n">kwargsupdate</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">update</span>
        <span class="n">kwargsset</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="fm">__setitem__</span>
        <span class="n">paramsget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">parameters</span><span class="o">.</span><span class="fm">__getitem__</span>
        <span class="n">argumentsget</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">arguments</span><span class="o">.</span><span class="fm">__getitem__</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_kwdargnames</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">paramsget</span><span class="p">(</span><span class="n">name</span><span class="p">)</span><span class="o">.</span><span class="n">kind</span>
            <span class="n">arg</span> <span class="o">=</span> <span class="n">argumentsget</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_KEYWORD</span><span class="p">:</span>
                <span class="n">kwargsupdate</span><span class="p">(</span><span class="n">arg</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">kwargsset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">arg</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">kwargs</span>

<div class="viewcode-block" id="BoundArguments.eval"><a class="viewcode-back" href="../../usage/advanced.html#typic.api.BoundArguments.eval">[docs]</a>    <span class="k">def</span> <span class="nf">eval</span><span class="p">(</span><span class="bp">self</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Any</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Evaluate the callable against the input provided.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import typic</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def foo(bar: int) -&gt; int:</span>
<span class="sd">        ...     return bar ** bar</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; bound = typic.bind(foo, &quot;2&quot;)</span>
<span class="sd">        &gt;&gt;&gt; bound.eval()</span>
<span class="sd">        4</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">obj</span><span class="p">(</span><span class="o">*</span><span class="bp">self</span><span class="o">.</span><span class="n">args</span><span class="p">,</span> <span class="o">**</span><span class="bp">self</span><span class="o">.</span><span class="n">kwargs</span><span class="p">)</span></div></div>


<div class="viewcode-block" id="TypeCoercer"><a class="viewcode-back" href="../../api/coercer.html#typic.api.TypeCoercer">[docs]</a><span class="k">class</span> <span class="nc">TypeCoercer</span><span class="p">:</span>
    <span class="sd">&quot;&quot;&quot;A callable class for coercing values.</span>

<span class="sd">    Checks for:</span>
<span class="sd">            - :class:`datetime.date`</span>
<span class="sd">            - :class:`datetime.datetime`</span>
<span class="sd">            - builtin types</span>
<span class="sd">            - extended type annotations as described in the ``typing`` module.</span>
<span class="sd">            - User-defined classes (limited)</span>

<span class="sd">    Examples</span>
<span class="sd">    --------</span>
<span class="sd">    &gt;&gt;&gt; import typic</span>
<span class="sd">    &gt;&gt;&gt; typic.coerce(&quot;foo&quot;, bytes)</span>
<span class="sd">    b&#39;foo&#39;</span>
<span class="sd">    &gt;&gt;&gt; typic.coerce(&quot;{&#39;foo&#39;: &#39;bar&#39;}&quot;, dict)</span>
<span class="sd">    {&#39;foo&#39;: &#39;bar&#39;}</span>
<span class="sd">    &quot;&quot;&quot;</span>

    <span class="n">DEFAULT_BYTE_ENCODING</span> <span class="o">=</span> <span class="s2">&quot;utf-8&quot;</span>
    <span class="n">UNRESOLVABLE</span> <span class="o">=</span> <span class="nb">frozenset</span><span class="p">(</span>
        <span class="p">(</span>
            <span class="n">Any</span><span class="p">,</span>
            <span class="n">Union</span><span class="p">,</span>
            <span class="n">Match</span><span class="p">,</span>
            <span class="n">re</span><span class="o">.</span><span class="n">Match</span><span class="p">,</span>  <span class="c1"># type: ignore</span>
            <span class="nb">type</span><span class="p">(</span><span class="kc">None</span><span class="p">),</span>
            <span class="n">_empty</span><span class="p">,</span>
        <span class="p">)</span>
    <span class="p">)</span>

    <span class="k">def</span> <span class="nf">__init__</span><span class="p">(</span><span class="bp">self</span><span class="p">):</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_resolved_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_coercer_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_schema_cache</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">schema_builder</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">SchemaBuilder</span><span class="p">()</span>
        <span class="k">for</span> <span class="n">typ</span> <span class="ow">in</span> <span class="n">checks</span><span class="o">.</span><span class="n">BUILTIN_TYPES</span><span class="p">:</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_build_coercer</span><span class="p">(</span><span class="n">typ</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_coercers</span><span class="p">:</span> <span class="n">CoercerRegistry</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>

<div class="viewcode-block" id="TypeCoercer.register"><a class="viewcode-back" href="../../api/coercer.html#typic.api.TypeCoercer.register">[docs]</a>    <span class="k">def</span> <span class="nf">register</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">coercer</span><span class="p">:</span> <span class="n">Coercer</span><span class="p">,</span> <span class="n">check</span><span class="p">:</span> <span class="n">CoercerTypeCheck</span><span class="p">):</span>
        <span class="sd">&quot;&quot;&quot;Register a user-defined coercer.</span>

<span class="sd">        In the rare case where typic can&#39;t figure out how to coerce your annotation</span>
<span class="sd">        correctly, a custom coercer may be registered alongside a check function which</span>
<span class="sd">        returns a simple boolean indicating whether this is the correct coercer for an</span>
<span class="sd">        annotation.</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_user_coercers</span><span class="o">.</span><span class="n">appendleft</span><span class="p">((</span><span class="n">check</span><span class="p">,</span> <span class="n">coercer</span><span class="p">))</span></div>

<div class="viewcode-block" id="TypeCoercer.seen"><a class="viewcode-back" href="../../api/coercer.html#typic.api.TypeCoercer.seen">[docs]</a>    <span class="k">def</span> <span class="nf">seen</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">cls_or_callable</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Callable</span><span class="p">,</span> <span class="n">Type</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="nb">bool</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">cls_or_callable</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_resolved_cache</span> <span class="ow">or</span> <span class="nb">hasattr</span><span class="p">(</span>
            <span class="n">cls_or_callable</span><span class="p">,</span> <span class="n">_ORIG_SETTER_NAME</span>
        <span class="p">)</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_set_checks</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">gen</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span> <span class="n">optional</span><span class="p">:</span> <span class="nb">bool</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">_empty</span><span class="p">):</span>
        <span class="n">_checks</span> <span class="o">=</span> <span class="p">[]</span>
        <span class="n">_ctx</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">optional</span><span class="p">:</span>
            <span class="n">_checks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;val is None&quot;</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">_empty</span><span class="p">:</span>
            <span class="n">_checks</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&quot;val == __default&quot;</span><span class="p">)</span>
            <span class="n">_ctx</span><span class="p">[</span><span class="s2">&quot;__default&quot;</span><span class="p">]</span> <span class="o">=</span> <span class="n">default</span>
        <span class="k">if</span> <span class="n">_checks</span><span class="p">:</span>
            <span class="n">check</span> <span class="o">=</span> <span class="s2">&quot; or &quot;</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">_checks</span><span class="p">)</span>
            <span class="n">func</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;if </span><span class="si">{check}</span><span class="s2">:&quot;</span><span class="p">,</span> <span class="o">**</span><span class="n">_ctx</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">()</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;return val&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_get_coercer_name</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">optional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="nb">str</span><span class="p">:</span>
        <span class="k">return</span> <span class="n">re</span><span class="o">.</span><span class="n">sub</span><span class="p">(</span><span class="sa">r</span><span class="s2">&quot;\W+&quot;</span><span class="p">,</span> <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">f</span><span class="s2">&quot;coerce_</span><span class="si">{annotation}</span><span class="s2">_</span><span class="si">{default}</span><span class="s2">_</span><span class="si">{optional}</span><span class="s2">&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_build_date_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">gen</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span> <span class="n">origin</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="n">datetime</span><span class="o">.</span><span class="n">datetime</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, datetime.date):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span>
                    <span class="s2">&quot;val = datetime.datetime(val.year, val.month, val.day)&quot;</span><span class="p">,</span>
                    <span class="n">datetime</span><span class="o">=</span><span class="n">datetime</span><span class="p">,</span>
                <span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="ow">is</span> <span class="n">datetime</span><span class="o">.</span><span class="n">date</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, datetime.datetime):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;val = val.date()&quot;</span><span class="p">,</span> <span class="n">datetime</span><span class="o">=</span><span class="n">datetime</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;elif isinstance(val, (int, float)):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">.fromtimestamp(val)&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;elif isinstance(val, (str, bytes)):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;val = dateparse(val)&quot;</span><span class="p">,</span> <span class="n">dateparse</span><span class="o">=</span><span class="n">dateparse</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_build_builtin_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">gen</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span> <span class="n">origin</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">if</span> <span class="nb">issubclass</span><span class="p">(</span><span class="n">origin</span><span class="p">,</span> <span class="n">Collection</span><span class="p">)</span> <span class="ow">and</span> <span class="n">origin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="p">{</span><span class="nb">str</span><span class="p">,</span> <span class="nb">bytes</span><span class="p">}:</span>
            <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, (str, bytes)):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;_, val = safe_eval(val)&quot;</span><span class="p">,</span> <span class="n">safe_eval</span><span class="o">=</span><span class="n">safe_eval</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">origin</span> <span class="ow">is</span> <span class="nb">bytes</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, str):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">(val, encoding=&#39;utf-8&#39;)&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;else:&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">(val)&quot;</span><span class="p">)</span>
        <span class="k">elif</span> <span class="n">origin</span> <span class="ow">is</span> <span class="nb">str</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, bytes):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;val = val.decode(&#39;utf-8&#39;)&quot;</span><span class="p">)</span>
            <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;else:&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">(val)&quot;</span><span class="p">)</span>
        <span class="k">else</span><span class="p">:</span>
            <span class="n">func</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">(val)&quot;</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_build_pattern_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">gen</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;if not isinstance(val, </span><span class="si">{anno_name}</span><span class="s2">):&quot;</span><span class="p">):</span>
            <span class="n">func</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;val = __re_compile(val)&quot;</span><span class="p">,</span> <span class="n">__re_compile</span><span class="o">=</span><span class="n">re</span><span class="o">.</span><span class="n">compile</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_build_fromdict_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">:</span> <span class="n">gen</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;if isinstance(val, </span><span class="si">{anno_name}</span><span class="s2">):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;return val&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, (str, bytes)):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;_, val = safe_eval(val)&quot;</span><span class="p">,</span> <span class="n">safe_eval</span><span class="o">=</span><span class="n">safe_eval</span><span class="p">)</span>
        <span class="n">func</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">.from_dict(val)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_mapping_coercer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">gen</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Type</span><span class="p">],</span> <span class="n">anno_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">):</span>
        <span class="n">key_type</span><span class="p">,</span> <span class="n">item_type</span> <span class="o">=</span> <span class="n">args</span>
        <span class="n">key_coercer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coercer</span><span class="p">(</span><span class="n">key_type</span><span class="p">)</span>
        <span class="n">item_coercer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coercer</span><span class="p">(</span><span class="n">item_type</span><span class="p">)</span>
        <span class="n">kc_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{anno_name}</span><span class="s2">_key_coercer&quot;</span>
        <span class="n">it_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{anno_name}</span><span class="s2">_item_coercer&quot;</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, (str, bytes)):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;_, val = safe_eval(val)&quot;</span><span class="p">,</span> <span class="n">safe_eval</span><span class="o">=</span><span class="n">safe_eval</span><span class="p">)</span>
        <span class="n">func</span><span class="o">.</span><span class="n">l</span><span class="p">(</span>
            <span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">((</span><span class="si">{kc_name}</span><span class="s2">(x), </span><span class="si">{it_name}</span><span class="s2">(y)) for x, y in </span><span class="si">{anno_name}</span><span class="s2">(val).items())&quot;</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="p">{</span><span class="n">kc_name</span><span class="p">:</span> <span class="n">key_coercer</span><span class="p">,</span> <span class="n">it_name</span><span class="p">:</span> <span class="n">item_coercer</span><span class="p">},</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_collection_coercer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">gen</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span> <span class="n">args</span><span class="p">:</span> <span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">anno_name</span><span class="p">:</span> <span class="nb">str</span>
    <span class="p">):</span>
        <span class="n">item_type</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
        <span class="n">item_coercer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coercer</span><span class="p">(</span><span class="n">item_type</span><span class="p">)</span>
        <span class="n">it_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{anno_name}</span><span class="s2">_item_coercer&quot;</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, (str, bytes)):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;_, val = safe_eval(val)&quot;</span><span class="p">,</span> <span class="n">safe_eval</span><span class="o">=</span><span class="n">safe_eval</span><span class="p">)</span>
        <span class="n">func</span><span class="o">.</span><span class="n">l</span><span class="p">(</span>
            <span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">(</span><span class="si">{it_name}</span><span class="s2">(x) for x in </span><span class="si">{anno_name}</span><span class="s2">(val))&quot;</span><span class="p">,</span>
            <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
            <span class="o">**</span><span class="p">{</span><span class="n">it_name</span><span class="p">:</span> <span class="n">item_coercer</span><span class="p">},</span>
        <span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_generic_coercer</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">func</span><span class="p">:</span> <span class="n">gen</span><span class="o">.</span><span class="n">Block</span><span class="p">,</span> <span class="n">origin</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">:</span> <span class="nb">str</span><span class="p">):</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;if isinstance(val, </span><span class="si">{anno_name}</span><span class="s2">):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;return val&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, (str, bytes)):&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;_, val = safe_eval(val)&quot;</span><span class="p">,</span> <span class="n">safe_eval</span><span class="o">=</span><span class="n">safe_eval</span><span class="p">)</span>
        <span class="n">params</span> <span class="o">=</span> <span class="p">{</span><span class="o">*</span><span class="n">cached_signature</span><span class="p">(</span><span class="n">origin</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">}</span>
        <span class="n">params_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{anno_name}</span><span class="s2">_params&quot;</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;if isinstance(val, Mapping):&quot;</span><span class="p">,</span> <span class="n">Mapping</span><span class="o">=</span><span class="n">Mapping</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span>
                <span class="n">f</span><span class="s2">&quot;val = {{x: val[x] for x in val.keys() &amp; </span><span class="si">{params_name}</span><span class="s2">}}&quot;</span><span class="p">,</span>
                <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                <span class="o">**</span><span class="p">{</span><span class="n">params_name</span><span class="p">:</span> <span class="n">params</span><span class="p">},</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="ow">not</span> <span class="bp">self</span><span class="o">.</span><span class="n">seen</span><span class="p">(</span><span class="n">origin</span><span class="p">):</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;bound = __bind(</span><span class="si">{anno_name}</span><span class="s2">, **val)&quot;</span><span class="p">,</span> <span class="n">__bind</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">bind</span><span class="p">)</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">(*bound.args, **bound.kwargs)&quot;</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">(**val)&quot;</span><span class="p">)</span>
        <span class="k">with</span> <span class="n">func</span><span class="o">.</span><span class="n">b</span><span class="p">(</span><span class="s2">&quot;else:&quot;</span><span class="p">)</span> <span class="k">as</span> <span class="n">b</span><span class="p">:</span>
            <span class="n">b</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{anno_name}</span><span class="s2">(val)&quot;</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_build_coercer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">_empty</span><span class="p">,</span> <span class="n">is_optional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Callable</span><span class="p">:</span>
        <span class="n">func_name</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_coercer_name</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">is_optional</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">func_name</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coercer_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coercer_cache</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span>
        <span class="c1"># Resolve any constraints *first*, since ConstrainedTypes are basically NewTypes</span>
        <span class="n">constraints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints_from_anno</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="c1"># Resolve NewTypes into their annotation. Recursive.</span>
        <span class="n">resolved</span> <span class="o">=</span> <span class="n">resolve_supertype</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">get_args</span><span class="p">(</span><span class="n">resolved</span><span class="p">)</span>
        <span class="c1"># Get the &quot;origin&quot; of the annotation. This will be a builtin for native types.</span>
        <span class="c1"># For custom types or classes, this will be the same as the annotation.</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">resolved</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">is_optional</span> <span class="ow">is</span> <span class="kc">None</span> <span class="ow">and</span> <span class="n">checks</span><span class="o">.</span><span class="n">isoptionaltype</span><span class="p">(</span><span class="n">resolved</span><span class="p">):</span>
            <span class="n">coercer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_coercer</span><span class="p">(</span><span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">is_optional</span><span class="o">=</span><span class="kc">True</span><span class="p">)</span>
            <span class="bp">self</span><span class="o">.</span><span class="n">_coercer_cache</span><span class="p">[</span><span class="n">func_name</span><span class="p">]</span> <span class="o">=</span> <span class="n">coercer</span>
            <span class="k">return</span> <span class="n">coercer</span>

        <span class="n">optional</span> <span class="o">=</span> <span class="n">is_optional</span> <span class="ow">or</span> <span class="kc">False</span>
        <span class="n">anno_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{func_name}</span><span class="s2">_anno&quot;</span>
        <span class="n">ns</span> <span class="o">=</span> <span class="p">{</span><span class="n">anno_name</span><span class="p">:</span> <span class="n">origin</span><span class="p">}</span>
        <span class="k">with</span> <span class="n">gen</span><span class="o">.</span><span class="n">Block</span><span class="p">(</span><span class="n">ns</span><span class="p">)</span> <span class="k">as</span> <span class="n">main</span><span class="p">:</span>
            <span class="k">with</span> <span class="n">main</span><span class="o">.</span><span class="n">f</span><span class="p">(</span><span class="n">func_name</span><span class="p">,</span> <span class="n">main</span><span class="o">.</span><span class="n">param</span><span class="p">(</span><span class="s2">&quot;val&quot;</span><span class="p">))</span> <span class="k">as</span> <span class="n">func</span><span class="p">:</span>
                <span class="k">if</span> <span class="n">origin</span> <span class="ow">not</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">UNRESOLVABLE</span><span class="p">:</span>
                    <span class="bp">self</span><span class="o">.</span><span class="n">_set_checks</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">optional</span><span class="p">,</span> <span class="n">default</span><span class="p">)</span>
                    <span class="k">if</span> <span class="n">checks</span><span class="o">.</span><span class="n">isdatetype</span><span class="p">(</span><span class="n">origin</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_date_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">origin</span> <span class="ow">in</span> <span class="p">{</span><span class="n">Pattern</span><span class="p">,</span> <span class="n">re</span><span class="o">.</span><span class="n">Pattern</span><span class="p">}:</span>  <span class="c1"># type: ignore</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_pattern_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="ow">not</span> <span class="n">args</span> <span class="ow">and</span> <span class="n">checks</span><span class="o">.</span><span class="n">isbuiltintype</span><span class="p">(</span><span class="n">origin</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_builtin_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">checks</span><span class="o">.</span><span class="n">isfromdictclass</span><span class="p">(</span><span class="n">origin</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_fromdict_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">checks</span><span class="o">.</span><span class="n">isenumtype</span><span class="p">(</span><span class="n">origin</span><span class="p">):</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_builtin_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">checks</span><span class="o">.</span><span class="n">ismappingtype</span><span class="p">(</span><span class="n">origin</span><span class="p">):</span>
                        <span class="n">args</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Type</span><span class="p">],</span> <span class="n">args</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_mapping_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">)</span>
                    <span class="k">elif</span> <span class="n">checks</span><span class="o">.</span><span class="n">iscollectiontype</span><span class="p">(</span><span class="n">origin</span><span class="p">):</span>
                        <span class="n">args</span> <span class="o">=</span> <span class="n">cast</span><span class="p">(</span><span class="n">Tuple</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="o">...</span><span class="p">],</span> <span class="n">args</span><span class="p">)</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_collection_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">)</span>
                    <span class="k">else</span><span class="p">:</span>
                        <span class="bp">self</span><span class="o">.</span><span class="n">_build_generic_coercer</span><span class="p">(</span><span class="n">func</span><span class="p">,</span> <span class="n">origin</span><span class="p">,</span> <span class="n">anno_name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">constraints</span><span class="p">:</span>
                    <span class="n">constr_name</span> <span class="o">=</span> <span class="n">f</span><span class="s2">&quot;</span><span class="si">{anno_name}</span><span class="s2">_constraints&quot;</span>
                    <span class="n">func</span><span class="o">.</span><span class="n">l</span><span class="p">(</span>
                        <span class="n">f</span><span class="s2">&quot;val = </span><span class="si">{constr_name}</span><span class="s2">.validate(val)&quot;</span><span class="p">,</span>
                        <span class="n">level</span><span class="o">=</span><span class="kc">None</span><span class="p">,</span>
                        <span class="o">**</span><span class="p">{</span><span class="n">constr_name</span><span class="p">:</span> <span class="n">constraints</span><span class="p">},</span>
                    <span class="p">)</span>
                <span class="n">func</span><span class="o">.</span><span class="n">l</span><span class="p">(</span><span class="s2">&quot;return val&quot;</span><span class="p">)</span>
        <span class="n">coercer</span> <span class="o">=</span> <span class="n">main</span><span class="o">.</span><span class="n">compile</span><span class="p">(</span><span class="n">ns</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">_coercer_cache</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">func_name</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">coercer</span>

<div class="viewcode-block" id="TypeCoercer.get_coercer"><a class="viewcode-back" href="../../api/coercer.html#typic.api.TypeCoercer.get_coercer">[docs]</a>    <span class="k">def</span> <span class="nf">get_coercer</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span> <span class="n">annotation</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">default</span><span class="p">:</span> <span class="n">Any</span> <span class="o">=</span> <span class="n">_empty</span><span class="p">,</span> <span class="n">is_optional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Coercer</span><span class="p">:</span>
        <span class="n">key</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_get_coercer_name</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">default</span><span class="p">,</span> <span class="n">is_optional</span><span class="p">)</span>
        <span class="k">if</span> <span class="n">key</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coercer_cache</span><span class="p">:</span>
            <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_coercer_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span>
        <span class="k">for</span> <span class="n">check</span><span class="p">,</span> <span class="n">coercer</span> <span class="ow">in</span> <span class="bp">self</span><span class="o">.</span><span class="n">_user_coercers</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">check</span><span class="p">(</span><span class="n">annotation</span><span class="p">):</span>
                <span class="bp">self</span><span class="o">.</span><span class="n">_coercer_cache</span><span class="p">[</span><span class="n">key</span><span class="p">]</span> <span class="o">=</span> <span class="n">coercer</span>
                <span class="k">return</span> <span class="n">coercer</span>

        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_build_coercer</span><span class="p">(</span><span class="n">annotation</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">,</span> <span class="n">is_optional</span><span class="o">=</span><span class="n">is_optional</span><span class="p">)</span></div>

<div class="viewcode-block" id="TypeCoercer.coerce_value"><a class="viewcode-back" href="../../api/coercer.html#typic.api.TypeCoercer.coerce_value">[docs]</a>    <span class="k">def</span> <span class="nf">coerce_value</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">value</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span> <span class="n">annotation</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Object</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Object</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Coerce the given value to the given annotation, if possible.</span>

<span class="sd">        Checks for:</span>
<span class="sd">            - :class:`datetime.date`</span>
<span class="sd">            - :class:`datetime.datetime`</span>
<span class="sd">            - builtin types</span>
<span class="sd">            - extended type annotations as described in the ``typing`` module.</span>
<span class="sd">            - User-defined classes (limited)</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        value :</span>
<span class="sd">            The value to be coerced</span>
<span class="sd">        annotation :</span>
<span class="sd">            The provided annotation for determining the coercion</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">resolved</span><span class="p">:</span> <span class="n">ResolvedAnnotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="n">coerced</span><span class="p">:</span> <span class="n">Object</span> <span class="o">=</span> <span class="n">resolved</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

        <span class="k">return</span> <span class="n">coerced</span></div>

    <span class="fm">__call__</span> <span class="o">=</span> <span class="n">coerce_value</span>  <span class="c1"># alias for easy access to most common operation.</span>

<div class="viewcode-block" id="TypeCoercer.resolve"><a class="viewcode-back" href="../../api/coercer.html#typic.api.TypeCoercer.resolve">[docs]</a>    <span class="nd">@cachedmethod</span>
    <span class="k">def</span> <span class="nf">resolve</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">annotation</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">origin</span><span class="p">:</span> <span class="n">Type</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">name</span><span class="p">:</span> <span class="nb">str</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">parameter</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">constraints</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">Constraints</span><span class="p">]</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
        <span class="n">is_optional</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">None</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">ResolvedAnnotation</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a :py:class:`ResolvedAnnotation` from a type.&quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">parameter</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">parameter</span> <span class="o">=</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
                <span class="s2">&quot;_&quot;</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span> <span class="n">annotation</span><span class="o">=</span><span class="n">annotation</span>
            <span class="p">)</span>
        <span class="c1"># Check for the super-type</span>
        <span class="n">non_super</span> <span class="o">=</span> <span class="n">resolve_supertype</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="n">origin</span> <span class="o">=</span> <span class="n">origin</span> <span class="ow">or</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="n">use</span> <span class="o">=</span> <span class="n">non_super</span>
        <span class="c1"># Get the unfiltered args</span>
        <span class="n">args</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">non_super</span><span class="p">,</span> <span class="s2">&quot;__args__&quot;</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="c1"># Set whether this is optional</span>
        <span class="k">if</span> <span class="n">is_optional</span> <span class="ow">is</span> <span class="kc">None</span><span class="p">:</span>
            <span class="n">is_optional</span> <span class="o">=</span> <span class="n">checks</span><span class="o">.</span><span class="n">isoptionaltype</span><span class="p">(</span><span class="n">non_super</span><span class="p">)</span>
        <span class="c1"># Determine whether we should use the first arg of the annotation</span>
        <span class="k">if</span> <span class="n">checks</span><span class="o">.</span><span class="n">should_unwrap</span><span class="p">(</span><span class="n">non_super</span><span class="p">)</span> <span class="ow">and</span> <span class="n">args</span><span class="p">:</span>
            <span class="n">use</span> <span class="o">=</span> <span class="n">args</span><span class="p">[</span><span class="mi">0</span><span class="p">]</span>
            <span class="c1"># Recurse on read-only and write-only</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">checks</span><span class="o">.</span><span class="n">iswriteonly</span><span class="p">(</span><span class="n">non_super</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">checks</span><span class="o">.</span><span class="n">isreadonly</span><span class="p">(</span><span class="n">non_super</span><span class="p">)</span>
                <span class="ow">or</span> <span class="n">checks</span><span class="o">.</span><span class="n">isfinal</span><span class="p">(</span><span class="n">non_super</span><span class="p">)</span>
            <span class="p">):</span>
                <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span>
                    <span class="n">use</span><span class="p">,</span>
                    <span class="n">origin</span><span class="o">=</span><span class="n">get_origin</span><span class="p">(</span><span class="n">non_super</span><span class="p">),</span>
                    <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span>
                    <span class="n">parameter</span><span class="o">=</span><span class="n">parameter</span><span class="p">,</span>
                    <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span><span class="p">,</span>
                    <span class="n">is_optional</span><span class="o">=</span><span class="n">checks</span><span class="o">.</span><span class="n">isoptionaltype</span><span class="p">(</span><span class="n">use</span><span class="p">),</span>
                <span class="p">)</span>
        <span class="c1"># Build the coercer</span>
        <span class="n">coercer</span><span class="p">:</span> <span class="n">Coercer</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">get_coercer</span><span class="p">(</span>
            <span class="n">use</span><span class="p">,</span> <span class="n">default</span><span class="o">=</span><span class="n">parameter</span><span class="o">.</span><span class="n">default</span><span class="p">,</span> <span class="n">is_optional</span><span class="o">=</span><span class="n">is_optional</span>
        <span class="p">)</span>
        <span class="c1"># Handle *args and **kwargs</span>
        <span class="k">if</span> <span class="n">parameter</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_POSITIONAL</span><span class="p">:</span>
            <span class="n">__coerce</span> <span class="o">=</span> <span class="n">coercer</span>

            <span class="k">def</span> <span class="nf">coercer</span><span class="p">(</span><span class="n">__val</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__coerce</span><span class="p">(</span><span class="n">x</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span> <span class="ow">in</span> <span class="n">__val</span><span class="p">),)</span>

        <span class="k">elif</span> <span class="n">parameter</span><span class="o">.</span><span class="n">kind</span> <span class="o">==</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">VAR_KEYWORD</span><span class="p">:</span>
            <span class="n">__coerce</span> <span class="o">=</span> <span class="n">coercer</span>

            <span class="k">def</span> <span class="nf">coercer</span><span class="p">(</span><span class="n">__val</span><span class="p">):</span>
                <span class="k">return</span> <span class="p">{</span><span class="n">x</span><span class="p">:</span> <span class="n">__coerce</span><span class="p">(</span><span class="n">y</span><span class="p">)</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">__val</span><span class="o">.</span><span class="n">items</span><span class="p">()}</span>

        <span class="n">resolved</span> <span class="o">=</span> <span class="n">ResolvedAnnotation</span><span class="p">(</span>
            <span class="n">annotation</span><span class="o">=</span><span class="n">non_super</span><span class="p">,</span>
            <span class="n">origin</span><span class="o">=</span><span class="n">origin</span><span class="p">,</span>
            <span class="n">un_resolved</span><span class="o">=</span><span class="n">annotation</span><span class="p">,</span>
            <span class="n">coercer</span><span class="o">=</span><span class="n">coercer</span><span class="p">,</span>
            <span class="n">parameter</span><span class="o">=</span><span class="n">parameter</span><span class="p">,</span>
            <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span> <span class="ow">or</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints_from_anno</span><span class="p">(</span><span class="n">annotation</span><span class="p">),</span>
        <span class="p">)</span>
        <span class="k">return</span> <span class="n">resolved</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_constraints_from_anno</span><span class="p">(</span><span class="n">annotation</span><span class="p">:</span> <span class="n">Type</span><span class="p">[</span><span class="n">Any</span><span class="p">])</span> <span class="o">-&gt;</span> <span class="n">Optional</span><span class="p">[</span><span class="n">const</span><span class="o">.</span><span class="n">Constraints</span><span class="p">]:</span>
        <span class="k">if</span> <span class="n">checks</span><span class="o">.</span><span class="n">isconstrained</span><span class="p">(</span><span class="n">annotation</span><span class="p">):</span>
            <span class="k">return</span> <span class="n">annotation</span><span class="o">.</span><span class="n">__constraints__</span>
        <span class="k">return</span> <span class="kc">None</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_constraints_from_hints</span><span class="p">(</span>
        <span class="n">hints</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Type</span><span class="p">]</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">const</span><span class="o">.</span><span class="n">Constraints</span><span class="p">]:</span>
        <span class="sd">&quot;&quot;&quot;Get the constraints associated to a typic.klass&quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="p">{</span>
            <span class="n">x</span><span class="p">:</span> <span class="n">y</span><span class="o">.</span><span class="n">__constraints__</span> <span class="k">for</span> <span class="n">x</span><span class="p">,</span> <span class="n">y</span> <span class="ow">in</span> <span class="n">hints</span><span class="o">.</span><span class="n">items</span><span class="p">()</span> <span class="k">if</span> <span class="n">checks</span><span class="o">.</span><span class="n">isconstrained</span><span class="p">(</span><span class="n">y</span><span class="p">)</span>
        <span class="p">}</span>

<div class="viewcode-block" id="TypeCoercer.annotations"><a class="viewcode-back" href="../../api/coercer.html#typic.api.TypeCoercer.annotations">[docs]</a>    <span class="nd">@fastcachedmethod</span>
    <span class="k">def</span> <span class="nf">annotations</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Annotations</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a mapping of param/attr name -&gt; :py:class:`ResolvedAnnotation`</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj</span>
<span class="sd">            The class or callable object you wish to extract resolved annotations from.</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import typic</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; @typic.klass</span>
<span class="sd">        ... class Foo:</span>
<span class="sd">        ...     bar: str</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; annotations = typic.annotations(Foo)</span>

<span class="sd">        See Also</span>
<span class="sd">        --------</span>
<span class="sd">        :py:class:`ResolvedAnnotation`</span>
<span class="sd">        &quot;&quot;&quot;</span>

        <span class="k">if</span> <span class="ow">not</span> <span class="nb">any</span><span class="p">(</span>
            <span class="p">(</span><span class="n">inspect</span><span class="o">.</span><span class="n">ismethod</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isfunction</span><span class="p">(</span><span class="n">obj</span><span class="p">),</span> <span class="n">inspect</span><span class="o">.</span><span class="n">isclass</span><span class="p">(</span><span class="n">obj</span><span class="p">))</span>
        <span class="p">):</span>
            <span class="n">obj</span> <span class="o">=</span> <span class="nb">type</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="n">sig</span> <span class="o">=</span> <span class="n">cached_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">hints</span> <span class="o">=</span> <span class="n">cached_type_hints</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">]</span> <span class="o">=</span> <span class="n">sig</span><span class="o">.</span><span class="n">parameters</span>
        <span class="n">fields</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">Field</span><span class="p">]</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">if</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">is_dataclass</span><span class="p">(</span><span class="n">obj</span><span class="p">):</span>
            <span class="n">fields</span> <span class="o">=</span> <span class="p">{</span><span class="n">f</span><span class="o">.</span><span class="n">name</span><span class="p">:</span> <span class="n">f</span> <span class="k">for</span> <span class="n">f</span> <span class="ow">in</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">fields</span><span class="p">(</span><span class="n">obj</span><span class="p">)}</span>
        <span class="n">all_constraints</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_constraints_from_hints</span><span class="p">(</span><span class="n">hints</span><span class="p">)</span>
        <span class="n">ann</span> <span class="o">=</span> <span class="p">{}</span>
        <span class="k">for</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">params</span><span class="o">.</span><span class="n">keys</span><span class="p">()</span> <span class="o">|</span> <span class="n">hints</span><span class="o">.</span><span class="n">keys</span><span class="p">():</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">hint</span> <span class="o">=</span> <span class="n">hints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">field</span> <span class="o">=</span> <span class="n">fields</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">constraints</span> <span class="o">=</span> <span class="n">all_constraints</span><span class="o">.</span><span class="n">get</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">hint</span> <span class="ow">or</span> <span class="n">param</span><span class="o">.</span><span class="n">annotation</span>  <span class="c1"># type: ignore</span>
            <span class="n">annotation</span> <span class="o">=</span> <span class="n">resolve_supertype</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
            <span class="n">param</span> <span class="o">=</span> <span class="n">param</span> <span class="ow">or</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">(</span>
                <span class="n">name</span><span class="p">,</span>
                <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="o">.</span><span class="n">POSITIONAL_OR_KEYWORD</span><span class="p">,</span>
                <span class="n">default</span><span class="o">=</span><span class="n">_empty</span><span class="p">,</span>
                <span class="n">annotation</span><span class="o">=</span><span class="n">hint</span> <span class="ow">or</span> <span class="n">annotation</span><span class="p">,</span>
            <span class="p">)</span>
            <span class="k">if</span> <span class="nb">repr</span><span class="p">(</span><span class="n">param</span><span class="o">.</span><span class="n">default</span><span class="p">)</span> <span class="o">==</span> <span class="s2">&quot;&lt;factory&gt;&quot;</span><span class="p">:</span>
                <span class="n">param</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">_empty</span><span class="p">)</span>
            <span class="k">if</span> <span class="n">annotation</span> <span class="ow">is</span> <span class="n">ClassVar</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="nb">getattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">name</span><span class="p">)</span>
                <span class="n">annotation</span> <span class="o">=</span> <span class="n">annotation</span><span class="p">[</span><span class="nb">type</span><span class="p">(</span><span class="n">val</span><span class="p">)]</span>
                <span class="n">default</span> <span class="o">=</span> <span class="n">val</span>
                <span class="n">param</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">default</span><span class="p">)</span>
            <span class="k">if</span> <span class="p">(</span>
                <span class="n">field</span>
                <span class="ow">and</span> <span class="n">field</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">dataclasses</span><span class="o">.</span><span class="n">MISSING</span>
                <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">_empty</span>
            <span class="p">):</span>
                <span class="k">if</span> <span class="n">field</span><span class="o">.</span><span class="n">init</span> <span class="ow">is</span> <span class="kc">False</span> <span class="ow">and</span> <span class="n">get_origin</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span> <span class="ow">is</span> <span class="ow">not</span> <span class="n">s</span><span class="o">.</span><span class="n">ReadOnly</span><span class="p">:</span>
                    <span class="n">annotation</span> <span class="o">=</span> <span class="n">s</span><span class="o">.</span><span class="n">ReadOnly</span><span class="p">[</span><span class="n">annotation</span><span class="p">]</span>  <span class="c1"># type: ignore</span>
                <span class="n">param</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">replace</span><span class="p">(</span><span class="n">default</span><span class="o">=</span><span class="n">field</span><span class="o">.</span><span class="n">default</span><span class="p">)</span>
            <span class="n">resolved</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span>
                <span class="n">annotation</span><span class="p">,</span> <span class="n">parameter</span><span class="o">=</span><span class="n">param</span><span class="p">,</span> <span class="n">name</span><span class="o">=</span><span class="n">name</span><span class="p">,</span> <span class="n">constraints</span><span class="o">=</span><span class="n">constraints</span>
            <span class="p">)</span>
            <span class="n">ann</span><span class="p">[</span><span class="n">name</span><span class="p">]</span> <span class="o">=</span> <span class="n">resolved</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_TYPIC_ANNOS_NAME</span><span class="p">,</span> <span class="n">ann</span><span class="p">)</span>
        <span class="c1"># We wrapped a bound method, or</span>
        <span class="c1"># are wrapping a static-/classmethod</span>
        <span class="c1"># after they were wrapped with @static/class</span>
        <span class="k">except</span> <span class="ne">AttributeError</span><span class="p">:</span>
            <span class="k">pass</span>

        <span class="k">return</span> <span class="n">ann</span></div>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_bind_posargs</span><span class="p">(</span>
        <span class="n">arguments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Deque</span><span class="p">[</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">],</span>
        <span class="n">annos</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ResolvedAnnotation</span><span class="p">],</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Deque</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="c1"># Bind any positional arguments</span>

        <span class="c1"># bytecode hack to localize access</span>
        <span class="c1"># only noticeable with really large datasets</span>
        <span class="c1"># but it&#39;s best to be prepared.</span>
        <span class="n">posargs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">posargsadd</span> <span class="o">=</span> <span class="n">posargs</span><span class="o">.</span><span class="n">append</span>
        <span class="n">argspop</span> <span class="o">=</span> <span class="n">args</span><span class="o">.</span><span class="n">popleft</span>
        <span class="n">paramspop</span> <span class="o">=</span> <span class="n">params</span><span class="o">.</span><span class="n">popleft</span>
        <span class="n">annosget</span> <span class="o">=</span> <span class="n">annos</span><span class="o">.</span><span class="n">get</span>
        <span class="n">argumentsset</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="fm">__setitem__</span>
        <span class="k">while</span> <span class="n">args</span> <span class="ow">and</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">val</span> <span class="o">=</span> <span class="n">argspop</span><span class="p">()</span>
            <span class="n">param</span><span class="p">:</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span> <span class="o">=</span> <span class="n">paramspop</span><span class="p">()</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span>
            <span class="n">anno</span><span class="p">:</span> <span class="n">Optional</span><span class="p">[</span><span class="n">ResolvedAnnotation</span><span class="p">]</span> <span class="o">=</span> <span class="n">annosget</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span>
            <span class="c1"># We&#39;ve got varargs, so push all supplied args to that param.</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                <span class="n">value</span> <span class="o">=</span> <span class="p">(</span><span class="n">val</span><span class="p">,)</span> <span class="o">+</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
                <span class="n">args</span> <span class="o">=</span> <span class="n">deque</span><span class="p">()</span>
                <span class="k">if</span> <span class="n">anno</span><span class="p">:</span>
                    <span class="n">value</span> <span class="o">=</span> <span class="n">anno</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>
                <span class="n">argumentsset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">posargsadd</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">break</span>

            <span class="c1"># We&#39;re not supposed to have kwdargs....</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="ow">in</span> <span class="n">_KWD_KINDS</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_TOO_MANY_POS</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">None</span>

            <span class="c1"># Passed in by ref and assignment... no good.</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;multiple values for argument &#39;</span><span class="si">{name}</span><span class="s2">&#39;&quot;</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">None</span>

            <span class="c1"># We&#39;re g2g</span>
            <span class="n">value</span> <span class="o">=</span> <span class="n">anno</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">anno</span> <span class="k">else</span> <span class="n">val</span>
            <span class="n">argumentsset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
            <span class="n">posargsadd</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>

        <span class="k">if</span> <span class="n">args</span><span class="p">:</span>
            <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">_TOO_MANY_POS</span><span class="p">)</span> <span class="kn">from</span> <span class="nn">None</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">posargs</span><span class="p">)</span>

    <span class="nd">@staticmethod</span>
    <span class="k">def</span> <span class="nf">_bind_kwdargs</span><span class="p">(</span>
        <span class="n">arguments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Deque</span><span class="p">[</span><span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">],</span>
        <span class="n">annos</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">ResolvedAnnotation</span><span class="p">],</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">Tuple</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="o">...</span><span class="p">]:</span>
        <span class="c1"># Bind any key-word arguments</span>
        <span class="n">kwdargs</span><span class="p">:</span> <span class="n">List</span><span class="p">[</span><span class="nb">str</span><span class="p">]</span> <span class="o">=</span> <span class="nb">list</span><span class="p">()</span>
        <span class="n">kwdargsadd</span> <span class="o">=</span> <span class="n">kwdargs</span><span class="o">.</span><span class="n">append</span>
        <span class="n">kwargs_anno</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">kwdargs_param</span> <span class="o">=</span> <span class="kc">None</span>
        <span class="n">kwargspop</span> <span class="o">=</span> <span class="n">kwargs</span><span class="o">.</span><span class="n">pop</span>
        <span class="n">annosget</span> <span class="o">=</span> <span class="n">annos</span><span class="o">.</span><span class="n">get</span>
        <span class="n">argumentsset</span> <span class="o">=</span> <span class="n">arguments</span><span class="o">.</span><span class="fm">__setitem__</span>
        <span class="k">for</span> <span class="n">param</span> <span class="ow">in</span> <span class="n">params</span><span class="p">:</span>
            <span class="n">kind</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">kind</span>
            <span class="n">name</span> <span class="o">=</span> <span class="n">param</span><span class="o">.</span><span class="n">name</span>
            <span class="n">anno</span> <span class="o">=</span> <span class="n">annosget</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="c1"># Move on, but don&#39;t forget</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_KEYWORD</span><span class="p">:</span>
                <span class="n">kwargs_anno</span> <span class="o">=</span> <span class="n">anno</span>
                <span class="n">kwdargs_param</span> <span class="o">=</span> <span class="n">param</span>
                <span class="k">continue</span>
            <span class="c1"># We don&#39;t care about these</span>
            <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_VAR_POSITIONAL</span><span class="p">:</span>
                <span class="k">continue</span>
            <span class="c1"># try to bind the parameter</span>
            <span class="k">if</span> <span class="n">name</span> <span class="ow">in</span> <span class="n">kwargs</span><span class="p">:</span>
                <span class="n">val</span> <span class="o">=</span> <span class="n">kwargspop</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
                <span class="k">if</span> <span class="n">kind</span> <span class="o">==</span> <span class="n">_POSITIONAL_ONLY</span><span class="p">:</span>
                    <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                        <span class="n">f</span><span class="s2">&quot;</span><span class="si">{name!r}</span><span class="s2"> parameter is positional only,&quot;</span>
                        <span class="s2">&quot;but was passed as a keyword.&quot;</span>
                    <span class="p">)</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">anno</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">val</span><span class="p">)</span> <span class="k">if</span> <span class="n">anno</span> <span class="k">else</span> <span class="n">val</span>
                <span class="n">argumentsset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">kwdargsadd</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">elif</span> <span class="ow">not</span> <span class="n">partial</span> <span class="ow">and</span> <span class="n">param</span><span class="o">.</span><span class="n">default</span> <span class="ow">is</span> <span class="n">_empty</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span><span class="n">f</span><span class="s2">&quot;missing required argument: </span><span class="si">{name!r}</span><span class="s2">&quot;</span><span class="p">)</span>

        <span class="c1"># We didn&#39;t clear out all the kwdargs. Check to see if we came across a **kwargs</span>
        <span class="k">if</span> <span class="n">kwargs</span><span class="p">:</span>
            <span class="k">if</span> <span class="n">kwdargs_param</span> <span class="ow">is</span> <span class="ow">not</span> <span class="kc">None</span><span class="p">:</span>
                <span class="c1"># Process our &#39;**kwargs&#39;-like parameter</span>
                <span class="n">name</span> <span class="o">=</span> <span class="n">kwdargs_param</span><span class="o">.</span><span class="n">name</span>
                <span class="n">value</span> <span class="o">=</span> <span class="n">kwargs_anno</span><span class="o">.</span><span class="n">coerce</span><span class="p">(</span><span class="n">kwargs</span><span class="p">)</span> <span class="k">if</span> <span class="n">kwargs_anno</span> <span class="k">else</span> <span class="n">kwargs</span>
                <span class="n">argumentsset</span><span class="p">(</span><span class="n">name</span><span class="p">,</span> <span class="n">value</span><span class="p">)</span>
                <span class="n">kwdargsadd</span><span class="p">(</span><span class="n">name</span><span class="p">)</span>
            <span class="k">else</span><span class="p">:</span>
                <span class="k">raise</span> <span class="ne">TypeError</span><span class="p">(</span>
                    <span class="n">f</span><span class="s2">&quot;&#39;got an unexpected keyword argument {next(iter(kwargs))!r}&#39;&quot;</span>
                <span class="p">)</span>

        <span class="k">return</span> <span class="nb">tuple</span><span class="p">(</span><span class="n">kwdargs</span><span class="p">)</span>

    <span class="k">def</span> <span class="nf">_bind_input</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">],</span>
        <span class="n">annos</span><span class="p">:</span> <span class="n">Annotations</span><span class="p">,</span>
        <span class="n">params</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">inspect</span><span class="o">.</span><span class="n">Parameter</span><span class="p">],</span>
        <span class="n">args</span><span class="p">:</span> <span class="n">Iterable</span><span class="p">[</span><span class="n">Any</span><span class="p">],</span>
        <span class="n">kwargs</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
        <span class="o">*</span><span class="p">,</span>
        <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoundArguments</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Bind annotations and parameters to received input.</span>

<span class="sd">        Taken approximately from :py:meth:`inspect.Signature.bind`, with a few changes.</span>

<span class="sd">        About 10% faster, on average, and coerces values with their annotation if possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        annos</span>
<span class="sd">            A mapping of :py:class:`ResolvedAnnotation` to param name.</span>
<span class="sd">        params</span>
<span class="sd">            A mapping of :py:class:`inspect.Parameter` to param name.</span>
<span class="sd">        args</span>
<span class="sd">            The positional args to bind to their param and annotation, if possible.</span>
<span class="sd">        kwargs</span>
<span class="sd">            The keyword args to bind to their param and annotation, if possible.</span>

<span class="sd">        Other Parameters</span>
<span class="sd">        ----------------</span>
<span class="sd">        partial</span>
<span class="sd">            Bind a partial input.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If we can&#39;t match up the received input to the signature</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="n">arguments</span><span class="p">:</span> <span class="n">Dict</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">]</span> <span class="o">=</span> <span class="nb">dict</span><span class="p">()</span>
        <span class="n">returns</span> <span class="o">=</span> <span class="n">annos</span><span class="o">.</span><span class="n">pop</span><span class="p">(</span><span class="n">_RETURN_KEY</span><span class="p">,</span> <span class="kc">None</span><span class="p">)</span>
        <span class="n">args</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">args</span><span class="p">)</span>
        <span class="n">parameters</span> <span class="o">=</span> <span class="n">deque</span><span class="p">(</span><span class="n">params</span><span class="o">.</span><span class="n">values</span><span class="p">())</span>
        <span class="c1"># Bind any positional arguments.</span>
        <span class="n">posargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind_posargs</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">annos</span><span class="p">,</span> <span class="n">args</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">)</span>
        <span class="c1"># Bind any keyword arguments.</span>
        <span class="n">kwdargs</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind_kwdargs</span><span class="p">(</span><span class="n">arguments</span><span class="p">,</span> <span class="n">parameters</span><span class="p">,</span> <span class="n">annos</span><span class="p">,</span> <span class="n">kwargs</span><span class="p">,</span> <span class="n">partial</span><span class="p">)</span>
        <span class="k">return</span> <span class="n">BoundArguments</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">annos</span><span class="p">,</span> <span class="n">params</span><span class="p">,</span> <span class="n">arguments</span><span class="p">,</span> <span class="n">returns</span><span class="p">,</span> <span class="n">posargs</span><span class="p">,</span> <span class="n">kwdargs</span><span class="p">)</span>

<div class="viewcode-block" id="TypeCoercer.bind"><a class="viewcode-back" href="../../api/coercer.html#typic.api.TypeCoercer.bind">[docs]</a>    <span class="k">def</span> <span class="nf">bind</span><span class="p">(</span>
        <span class="bp">self</span><span class="p">,</span>
        <span class="n">obj</span><span class="p">:</span> <span class="n">Union</span><span class="p">[</span><span class="n">Type</span><span class="p">,</span> <span class="n">Callable</span><span class="p">],</span>
        <span class="o">*</span><span class="n">args</span><span class="p">:</span> <span class="n">Any</span><span class="p">,</span>
        <span class="n">partial</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">,</span>
        <span class="n">coerce</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">True</span><span class="p">,</span>
        <span class="o">**</span><span class="n">kwargs</span><span class="p">:</span> <span class="n">Mapping</span><span class="p">[</span><span class="nb">str</span><span class="p">,</span> <span class="n">Any</span><span class="p">],</span>
    <span class="p">)</span> <span class="o">-&gt;</span> <span class="n">BoundArguments</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Bind a received input to a callable or object&#39;s signature.</span>

<span class="sd">        If we can locate an annotation for any args or kwargs, we&#39;ll automatically</span>
<span class="sd">        coerce as well.</span>

<span class="sd">        This implementation is similar to :py:meth:`inspect.Signature.bind`,</span>
<span class="sd">        but is ~10-20% faster.</span>
<span class="sd">        We also use a cached the signature to avoid the expense of that call if possible.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj</span>
<span class="sd">            The object you wish to bind your input to.</span>
<span class="sd">        *args</span>
<span class="sd">            The given positional args.</span>
<span class="sd">        partial</span>
<span class="sd">            Whether to bind a partial input.</span>
<span class="sd">        **kwargs</span>
<span class="sd">            The given keyword args.</span>

<span class="sd">        Returns</span>
<span class="sd">        -------</span>
<span class="sd">        :py:class:`BoundArguments`</span>
<span class="sd">            The bound and coerced arguments.</span>

<span class="sd">        Raises</span>
<span class="sd">        ------</span>
<span class="sd">        TypeError</span>
<span class="sd">            If we can&#39;t match up the received input to the signature</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import typic</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; def add(a: int, b: int, *, c: int = None) -&gt; int:</span>
<span class="sd">        ...     return a + b + (c or 0)</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; bound = typic.bind(add, &quot;1&quot;, &quot;2&quot;, c=3.0)</span>
<span class="sd">        &gt;&gt;&gt; bound.arguments</span>
<span class="sd">        {&#39;a&#39;: 1, &#39;b&#39;: 2, &#39;c&#39;: 3}</span>
<span class="sd">        &gt;&gt;&gt; bound.args</span>
<span class="sd">        (1, 2)</span>
<span class="sd">        &gt;&gt;&gt; bound.kwargs</span>
<span class="sd">        {&#39;c&#39;: 3}</span>
<span class="sd">        &gt;&gt;&gt; bound.eval()</span>
<span class="sd">        6</span>
<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">return</span> <span class="bp">self</span><span class="o">.</span><span class="n">_bind_input</span><span class="p">(</span>
            <span class="n">obj</span><span class="o">=</span><span class="n">obj</span><span class="p">,</span>
            <span class="n">annos</span><span class="o">=</span><span class="bp">self</span><span class="o">.</span><span class="n">annotations</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span> <span class="k">if</span> <span class="n">coerce</span> <span class="k">else</span> <span class="p">{},</span>
            <span class="n">params</span><span class="o">=</span><span class="n">cached_signature</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span><span class="o">.</span><span class="n">parameters</span><span class="p">,</span>
            <span class="n">args</span><span class="o">=</span><span class="n">args</span><span class="p">,</span>
            <span class="n">kwargs</span><span class="o">=</span><span class="n">kwargs</span><span class="p">,</span>
            <span class="n">partial</span><span class="o">=</span><span class="n">partial</span><span class="p">,</span>
        <span class="p">)</span></div>

<div class="viewcode-block" id="TypeCoercer.schema"><a class="viewcode-back" href="../../api/coercer.html#typic.api.TypeCoercer.schema">[docs]</a>    <span class="k">def</span> <span class="nf">schema</span><span class="p">(</span><span class="bp">self</span><span class="p">,</span> <span class="n">obj</span><span class="p">:</span> <span class="n">Type</span><span class="p">,</span> <span class="o">*</span><span class="p">,</span> <span class="n">primitive</span><span class="p">:</span> <span class="nb">bool</span> <span class="o">=</span> <span class="kc">False</span><span class="p">)</span> <span class="o">-&gt;</span> <span class="s2">&quot;s.ObjectSchemaField&quot;</span><span class="p">:</span>
        <span class="sd">&quot;&quot;&quot;Get a JSON schema for object for the given object.</span>

<span class="sd">        Parameters</span>
<span class="sd">        ----------</span>
<span class="sd">        obj</span>
<span class="sd">            The class for which you wish to generate a JSON schema</span>
<span class="sd">        primitive</span>
<span class="sd">            Whether to return an instance of :py:class:`typic.schema.ObjectSchemaField` or</span>
<span class="sd">            a &quot;primitive&quot; (dict object).</span>

<span class="sd">        Examples</span>
<span class="sd">        --------</span>
<span class="sd">        &gt;&gt;&gt; import typic</span>
<span class="sd">        &gt;&gt;&gt;</span>
<span class="sd">        &gt;&gt;&gt; @typic.klass</span>
<span class="sd">        ... class Foo:</span>
<span class="sd">        ...     bar: str</span>
<span class="sd">        ...</span>
<span class="sd">        &gt;&gt;&gt; typic.schema(Foo)</span>
<span class="sd">        ObjectSchemaField(title=&#39;Foo&#39;, description=&#39;Foo(bar: str)&#39;, properties={&#39;bar&#39;: StrSchemaField()}, additionalProperties=False, required=(&#39;bar&#39;,))</span>
<span class="sd">        &gt;&gt;&gt; typic.schema(Foo, primitive=True)</span>
<span class="sd">        {&#39;type&#39;: &#39;object&#39;, &#39;title&#39;: &#39;Foo&#39;, &#39;description&#39;: &#39;Foo(bar: str)&#39;, &#39;properties&#39;: {&#39;bar&#39;: {&#39;type&#39;: &#39;string&#39;}}, &#39;additionalProperties&#39;: False, &#39;required&#39;: [&#39;bar&#39;], &#39;definitions&#39;: {}}</span>

<span class="sd">        &quot;&quot;&quot;</span>
        <span class="k">if</span> <span class="n">obj</span> <span class="ow">in</span> <span class="p">{</span><span class="n">FunctionType</span><span class="p">,</span> <span class="n">MethodType</span><span class="p">}:</span>
            <span class="k">raise</span> <span class="ne">ValueError</span><span class="p">(</span><span class="s2">&quot;Cannot build schema for function or method.&quot;</span><span class="p">)</span>

        <span class="n">annotation</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">resolve</span><span class="p">(</span><span class="n">obj</span><span class="p">)</span>

        <span class="n">schema</span> <span class="o">=</span> <span class="bp">self</span><span class="o">.</span><span class="n">schema_builder</span><span class="o">.</span><span class="n">get_field</span><span class="p">(</span><span class="n">annotation</span><span class="p">)</span>
        <span class="bp">self</span><span class="o">.</span><span class="n">_schema_cache</span><span class="p">[</span><span class="n">obj</span><span class="p">]</span> <span class="o">=</span> <span class="n">schema</span>
        <span class="k">try</span><span class="p">:</span>
            <span class="nb">setattr</span><span class="p">(</span><span class="n">obj</span><span class="p">,</span> <span class="n">_SCHEMA_NAME</span><span class="p">,</span> <span class="n">schema</span><span class="p">)</span>
        <span class="k">except</span> <span class="p">(</span><span class="ne">AttributeError</span><span class="p">,</span> <span class="ne">TypeError</span><span class="p">):</span>
            <span class="k">pass</span>
        <span class="k">return</span> <span class="n">schema</span><span class="o">.</span><span class="n">asdict</span><span class="p">()</span> <span class="k">if</span> <span class="n">primitive</span> <span class="k">else</span> <span class="n">schema</span></div></div>
</pre></div>

          </div>
              <div class="related bottom">
                &nbsp;
  <nav id="rellinks">
    <ul>
    </ul>
  </nav>
              </div>
          
        </div>
      </div>
    <div class="clearer"></div>
  </div>
    <div class="footer">
      &copy;Copyright 2019 Sean Stewart.
      
      |
      Powered by <a href="http://sphinx-doc.org/">Sphinx 2.2.1</a>
      &amp; <a href="https://github.com/bitprophet/alabaster">Alabaster 0.7.12</a>
      
    </div>

    

    
  </body>
</html>